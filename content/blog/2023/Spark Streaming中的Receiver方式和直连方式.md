---
title: "Spark Streaming中的Receiver方式和直连方式"
date: 2018-10-31 11:45:01
draft: false
---
Spark Streaming从Kafka中接受数据的时候有两种方式，一种是使用Receiver的老方法，另一种是使用直连的方法

**1.Receiver方式**

Receiver是使用Kafka高级消费者API实现的，与所有接收器一样，从Kafka通过Receiver接收的数据存储在Spark执行器中，然后由Spark Streaming启动的作业处理数据

但是，在默认配置下，此方法可能会在失败时丢失数据，为确保零数据丢失，必须在Spark Streaming中另外启用Write Ahead Logs(在Spark 1.2中引入)，这将同步保存所有收到的Kafka将数据写入分布式文件系统（例如HDFS）上的预写日志，以便在发生故障时可以恢复所有数据

简单来说就是Receiver方式就是从Kafka中拉取数据，每次接受固定时间间隔的数据存储到内存中，但是这样可能会因为数据量太大，而造成内存溢出，所以必须使用WAL，将溢出的部分保存到HDFS或者磁盘中，以保证数据不丢失

这种方式效率很低，还容易丢失数据，在实际生产中已经不怎么使用了

**2.直连方式**

Spark 1.3中引入了这种新的无接收器“直接”方法，以确保更强大的端到端保证，这种方法不是使用接收器来接收数据，而是定期向Kafka查询每个主题+分区中的最新偏移量，并相应地定义要在每个批次中处理的偏移量范围。当启动处理数据的作业时，Kafka的简单消费者API用于读取Kafka定义的偏移范围（类似于从文件系统读取的文件）

该方法是直接将RDD中的分区连接到Kafka的分区上，相当于连接了一条水管，这样读取数据的效率更高

两种方法对比：

Receiver接收固定时间间隔的数据放在内存中，使用Kafka的高级API，自动维护偏移量，数据达到固定的时间才进行处理，效率低并且容易丢失数据

Direct直连方式，相当于直接连接到Kafka的分区上，使用Kafka底层的API，效率高，但是需要自己维护偏移量