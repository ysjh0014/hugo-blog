---
title: "如何处理死锁"
date: 2019-03-18 20:07:05
draft: false
---
**目前处理死锁的方法可归结为四种：**

预防死锁

避免死锁

检测死锁

解除死锁

**1.预防死锁**

预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，避免发生死锁

**由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证**

**1).破坏请求和保持条件**

为了能破坏请求和保持条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源

可以通过下面两个协议实现：

第一种协议：所有进程在运行之前，一次性申请其所需要的全部资源，如果系统有足够的资源分配给某进程，便把它所需要的所有资源分配给它，这样该进程在运行期间就不会再提出资源请求，从而破坏了请求条件；系统中只要有一种资源不能满足进程的要求，即使其他所需要的资源都空闲也不会分配给该进程，由于该进程在等待期间没有占用任何资源，从而破坏了保持条件，从而可以预防死锁的发生

优点：简单、易行、安全

缺点：资源被严重浪费，严重的降低了资源的利用率，进程在开始运行时就一次性的占用了整个运行过程所需的全部资源

使进程经常发生饥饿现象，因为仅当进程在获得了所需的全部资源后才会开始运行，这样就可能由于个别资源长期被其他进程占用，导致等待该资源的进程迟迟不能开始运行

第二种协议：这个协议是对第一种协议的改进，它允许一个进程只获得运行初期所需要的资源后，便开始运行，在运行过程中再逐步释放已经分配给自己并且已经用完的全部资源，然后再请求新的资源

优点：使进程更快的完成任务，提高设备的利用率，还可以减少进程发生饥饿的几率

**2).破坏不可抢占条件**

协议中规定：当一个进程已经保持了某些不可被抢占资源，又提出了新的资源请求不能得到满足时，它必须释放已经保持的所有资源，等到以后需要时再重新申请，这就意味着进程已占有的资源会被暂时的释放，这样就破坏了不可抢占条件

**3).破坏循环等待条件**

对系统中所有资源类型进行线性排序，并赋予不同的序号。然后采用这样的预防协议：规定每个进程必须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源的单元，以后当且仅当F(Rj)>F(Ri)时，进程才可以请求资源Rj的单元。如果需要多个同类资源单元， 则必须一起请求

采用这种策略，如何规定每种资源的序号十分重要，通常根据大多数进程需要资源的先后顺序来确定

**2.避免死锁**

避免死锁跟前面的预防死锁都是属于事先预防的策略，但并不是实现采取某种限制条件，破坏产生死锁的必要条件，而是在资源动态分配的过程中，防止系统进入不安全状态，以避免发生死锁

当系统处于安全状态时，可避免发生死锁，当系统处于不安全状态时，就可能进入到死锁状态

安全状态：所谓安全状态，是指系统能按某种进程推进顺序(P1，P2，......Pn)为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。此时称(P1，P2，......Pn)为安全序列。如果系统无法找到这样的一个序列，系统就处于不安全状态

**利用银行家算法避免死锁**

每一个进程在进入系统时，必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应该超过系统所拥有的资源总量，当进程请求一组资源时，系统首先必须确认是否有足够的资源分配给该进程，若有，会再进一步计算将这些资源分配给进程后，是否会使系统处于不安全的状态，如果不会，才将资源分配给它，否则让进程等待

**银行家算法中的数据结构：**

可利用资源向量Available

最大需求矩阵Max

分配矩阵Allocation

需求矩阵Need

设Request(i)是进程P(i)的请求向量

1).如果Request(i)[j]<=Need[i，j]，便转向步骤2；否则认为出错，因为它所需要的资源数已经超过它所宣布的最大值

2).如果Request(i)p[j]<=Available[j]，便转向步骤3；否则认为出错，因为系统中还没有它所需要的足够的资源，P(i)必须等待

3).系统尝试着把资源分配给进程P(i)，并修改数据结构中的数值

Available[j]=Available[j]-Request(i)[j]；

Allocation[i，j]=Allocation[i，j]+Request(i)[j]；

Need[i，j]=Need[i，j]-Request(i)[j]；

4).执行安全性算法，检查系统是否处于安全状态。如果安全，会正式将资源分配给进程P(i)，否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程P(i)等待

**安全性算法：**

1).设置两个变量，第一个是工作向量Work，它表示系统可提供给进程继续运行所需要的各类资源数目，它含有m个元素，在执行安全性算法时，Work=Available，第二个是Finish，它表示系统是否有足够的资源分配给进程。开始时先使Finish[i]=false；当有足够资源分配给进程时，再使Finish[i]=true

2).从进程集合中找到一个能满足下面条件的进程：

Finish[i]=false;

Need[i，j]<=Work[j];

如果找到，执行步骤3，否则执行步骤4

3).当进程Pi获得资源后，可以顺利执行，直至完成，并释放出分配给它的资源，所以应该执行：

Work[j]=Work[j]+Allocation[i，j]；

Finish[i]=true；

go to step 2；

4).如果所有进程的Finish[i]=true，则表示系统处于安全状态，否则系统处于不安全状态

**3.死锁的检测**

当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。检测到死锁时，一个可行的方法是释放所有锁，回退，并且等待一段随机的时间后重试

**4.死锁的解除**

常用的解除死锁的两种方法是：

1).抢占资源，从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态

2).终止进程，终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来