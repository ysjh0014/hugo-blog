---
title: "Java并发"
date: 2022-02-01T13:55:35+08:00
draft: false
---
##### ***API与SPI的区别***
从广义上来说，API和SPI都是接口
API是由服务提供方来提供，调用方来负责调用
##### ***产生死锁的四个必要条件***
1.互斥条件：该资源任意一个时刻只能由一个线程占用
2.请求与保持条件：一个线程因请求资源而阻塞时，对以获得的资源保持不放
3.不可剥夺条件：线程对已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完之后才能释放资源
4.循环等待条件：若干个线程之间形成一种头尾相连的循环等待资源关系
##### ***如果预防死锁***
破坏产生死锁的三个必要条件：
破坏请求与保持条件：一次性申请所有的资源
破坏不可剥夺条件：占有部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
破坏循环等待条件：靠按序申请资源来预防，按照某一顺序申请资源，释放资源则反序释放，破坏循环等待条件
##### ***如何避免死锁***
避免死锁是指在资源分配时，借助于算法，比如银行家算法，对资源分配进行计算评估，使其进入安全状态
安全状态是指系统能够按照某种线程推进顺序（P1、P2、P3....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可以顺利完成，称这个序列为安全序列
##### ***进程和线程的区别***
一个进程中有多个线程，多个线程共享进程的堆和方法区，但是每个线程又有自己的程序计数器，虚拟机栈和本地方法栈
线程是进程划分的更小的运行单位，线程和进程最大的区别在于基本上各进程是独立的，而各线程则不一定，因为同一进程间的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，而进程正好相反
##### ***线程的生命周期和状态***
初始状态 运行状态 阻塞状态 等待状态 超时等待状态 终止状态
##### ***创建线程有哪几种方式***
继承Thread类，创建一个Thread类的子类，重写这个类的run方法，然后调用start方法启动该线程
实现Runnable接口，创建一个该接口的实现类，重写这个类的run方法，然后调用start方法启动该线程
实现Callable接口，创建一个callable接口的实现类，重写这个类的call方法，可以得到一个Future类型的返回值
##### ***Runnable和Callable接口的区别***
Runnable不会返回结果或者抛出检查异常，Callable接口可以，
##### ***为什么要用线程池，如何创建线程池***
为什么：
降低资源消耗。通过重复利用已创建的线程来降低线程创建和销毁造成的资源消耗
提高响应速度。当任务到达时，不需要等待线程创建就可以立即执行
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会造成资源消耗，还会降低系统的稳定性，使用线程池可以进行统一的分配、监控和调优
如何创建：

##### ***ThreadPoolExecutor构造函数参数***

##### ***线程池的底层工作原理***

##### ***线程池的拒绝策略***

##### ***volatile关键字的作用***
1.
##### ***synchronized关键字的使用***

##### ***synchronized的实现原理***

##### ***synchronized和volatile的区别***

##### ***CAS***
CAS叫做CompareAndSwap 比较并交换，主要是通过处理器的指令来保证操作的原子性
CAS指令包含3个参数，共享变量的内存地址A，预期的值B和共享变量的新值C
只有当内存中地址A处的值等于B时，才能将内存中地址A的值更新为新值C，作为一条CPU指令，CAS本身是能够保证原子性的
##### ***CAS有什么问题，怎么解决***
ABA问题
并发环境下，假设初始条件是A，发现是A就执行修改，但是看到的虽然是A，中间可能经过了从A变成B，又从B变成A的情况，此时的A已经非彼A，
即使成功修改数据，也可能会有问题
解决方法：
使用版本号的方式，
循环性能开销问题
解决方法：


只能保证一个变量原子操作问题
##### ***什么是上下文切换***
使用多线程的目的是为了充分利用CPU，但是并发其实是一个CPU应付多个线程，为了让用户感觉多个线程是在同时执行的，CPU资源的分配采用时间片轮转的方式来为每个线程分配一个时间片，
线程在时间片内占用CPU执行任务，线程使用完时间片后，就会处于就绪状态并让出CPU给其他线程占用，这就是上下文切换
##### ***ThreadLocal是什么，工作中的使用***


##### ***线程池中的excute和submit方法有什么区别***
execute方法用于提交不需要返回值的任务
submit方法用于提交需要返回值的任务，线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get方法获取返回值





