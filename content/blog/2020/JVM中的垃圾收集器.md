---
title: "JVM中的垃圾收集器"
date: 2020-03-23 10:15:24
draft: false
---
**1.Serial收集器**

Serial收集器是单线程的收集器，它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成

Serial收集器是虚拟机运行在Client模式下的默认新生代垃圾收集器

适用于单CPU，新生代空间较小以及对暂停时间要求不高的应用

**2.ParNew收集器**

ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾回收之外，其他行为包括Serial收集器可用的所有控制参数，收集算法，对象分配规则，回收策略等都与Serial收集器完全一样

ParNew收集器是许多运行在Server模式下的虚拟机首选新生代收集器，除了性能高以外，只有它和Serial收集器能与CMS收集器配合工作

**3.Parallel Scavenge收集器**

Parallel Scavenge的目的是达到一个可控制的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)高吞吐量可以高效率的利用CPU，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务

Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的参数：-XX：MaxGCPauseMillis以及直接设置吞吐量大小的参数：-XX：GCTimeRatio

Parallel Scavenge收集器还有一个开关参数：-XX：+UseAdaptiveSizePolicy，当这个参数打开时，就不需要手动指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数，只需要把基本的内存数据设置好(如-Xmx设置最大堆)，然后使用上边的两个参数给虚拟机设立一个优化目标即可

**4.Serial Old收集器**

Serial Old收集器是Serial收集器的老年代版本，它也是一个单线程的收集器，使用标记-整理算法，进行垃圾回收时，必须暂停其他工作线程

**5.Parallel Old收集器**

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法，这个收集器在JDK1.6中才开始提供，通过参数：-XX：+UseParallelOldGC使用Parallel Scavenge+Parallel Old收集器组合进行内存回收

**6.CMS收集器**

CMS收集器是以获取最短回收停顿时间为目标的收集器，采用的是标记-清除算法，回收完毕后，会产生多个空闲空间，因此使用free-list的方式来记录老年代空间中哪些部分是空闲的，默认开启的回收线程数是(并行GC线程数+3)/4

free-list是一种数据结构，该数据结构用来管理那些回收再利用的内存空间

**CMS的过程：**

初始标记：

暂停整个应用，然后遍历老年代中所有的GC Root对象和新生代中存活的对象引用到的老年代的对象(指的是新生代中还活着的引用类型对象，引用指向老年代中的对象)，使用多线程对这些对象进行标记

并发标记：

恢复所用应用程序，对初始标记中标记的存活对象进行轮循，标记这些对象为可达对象

重新标记：

暂停整个应用，对上一步中修改的对象引用关系或者创建的新对象进行扫描，并重新进行标记

并发收集：

恢复所有应用程序，将没有标记的对象进行回收

**CMS收集器优点：**并发收集、低停顿

**CMS收集器缺点：**

1).CMS收集器对CPU资源非常敏感，CPU个数少于4个时，CMS对于用户程序的影响就会变得很大，默认启动的回收线程数是(CPU数量+3)/4，当CPU数量不足4个时，如果CPU负载本来就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低，为了应付这种情况，虚拟机提供了一种称为"增量式并发收集器"的CMS收集器变种

2).CMS收集器无法处理浮动垃圾，无法处理在回收时产生的新垃圾，因此会预留一部分空间存放新垃圾，默认老年代空间被占用达到一定百分比时，会触发Full GC

3).产生内存碎片，CMS是基于标记-清除算法的收集器，垃圾回收完后会产生大量的内存碎片，当大对象没有足够的连续空间来分配时，不得不提前触发一次Full GC

**7.G1收集器**

G1收集器采用并行与并发，利用多CPU，多核缩短整个应用暂停的时间，使用分代收集，整体基于标记-整理算法，局部基于复制算法，不会产生空间碎片

使用G1收集器，Java堆的内存布局是整体规划为多个大小相等的独立区域(Region)，虽然还保留新生代核老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合

G1收集器过程大概分为4步：

初始标记

并发标记

最终标记

筛选回收

GC的主要回收区域就是年轻代、老年代、持久代，在JDK8以后，持久代消失，被替换成了元空间

**串行垃圾回收器：**

Serial：用于新生代垃圾收集，采用复制算法

Serial Old：用于老年代垃圾收集，采用标记-整理算法

**并行垃圾回收器：**

ParNew：用于新生代，采用复制算法

Parallel Scavenge：用于新生代，采用复制算法

Parallel Old：用于老年代，采用标记-整理算法

**并发垃圾回收器：**

CMS：采用标记-清除算法，用于老年代

**垃圾收集器搭配使用情况：**

![](https://images2015.cnblogs.com/blog/467583/201706/467583-20170628093656618-2097152177.png)