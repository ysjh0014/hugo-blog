---
title: "Java面试题之数据库"
date: 2020-03-24 16:56:25
draft: false
featured_image: "https://hugo-ys.oss-cn-hangzhou.aliyuncs.com/static/img/java.png"
tags:
- Java
categories: 
- Java
---
**1.索引**

[Mysql数据库中的索引](https://blog.csdn.net/ys_230014/article/details/88773918)

**2.存储引擎**

[Mysql数据库中的存储引擎](https://blog.csdn.net/ys_230014/article/details/88778960)

**3.事务**

**事务：**事务是指逻辑上的一组操作，要么全部成功，要么全部失败

Mysql事务主要用来处理操作量大，复杂度高的数据。比如，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这些数据库操作语句就构成一个语句

**事物的特征：**

原子性：是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生

一致性：指事务前后数据的完整性必须保持一致

隔离性：指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离

永久性：指一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响

**Mysql的事务隔离级别：**

1).Read Uncommitted(读取未提交内容)

所有事务都可以看到其他未提交事务的执行结果，会带来脏读的问题

2).Read Committed(读取提交内容)：解决了脏读

一个事务只能看到已经提交事务所做的改变，这种隔离级别支持不可重复读，因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同结果

3).Repeatable Read(可重读)：解决了脏读和不可重复读

这是Mysql默认的事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这会导致幻读：当用户读取某一范围内的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的”幻影“行。InnoDB和Falcon存储引擎通过多版本并发控制(MVCC)机制解决了该问题

4).Serializable(可串行化)：解决了脏读、不可重复读、幻读

通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争

**4.数据库范式**

第一范式：

数据库表的每一列都是不可分割的基本数据项

第二范式：

实体的非主属性完全依赖于主关键字(消除非主属性对主键的部分函数依赖)

第三范式：

任何非主属性不依赖于其它非主属性(消除非主属性对主键的传递函数依赖)

**5.SQL注入**

SQL注入：将用于输入的查询参数，直接拼接在SQL语句中，导致了SQL注入

防止SQL注入的方法：

1).过滤URL中的一些特殊字符(使用正则表达式)

2).使用PrepareStatement，SQL注入只对SQL语句的编译过程有破坏作用，而PrepareStatement已经编译好了，执行阶段只是把输入串作为数据处理，不再对SQL语句进行解析，因此避免了SQL注入问题

3).使用javascript在客户端进行不安全字符屏蔽